u-boot的概念:
	u-boot是一段在系统上电后执行的小程序, 主要完成初始化硬件设备, 准备好软件环境, 最后调用操作系统内核等功能.
	Bootloader的功能依赖于硬件, 针对不同的嵌入式系统需要进行不同的配置.
	
BootLoader的启动方式:
	CPU上电以后, 会从某个地址开始执行:
		ARM结构的CPU的地址是0x0000 0000开始;
		MIPS结构的CPU的地址是0xBFC0 0000;
	BootLoader两种操作模式:
		(1) 启动加载模式
			上电后, BootLoader从板子的某个固态存储器上将操作系统加载到RAM中运行, 整儿过程没有用户的介入.
		(2) 下载模式
			开发人员可以利用各种命令, 通过串口连接或网络连接等从主机Host下载文件, 将它们直接放在内存运行或是烧写入Flash固态存储器中.
				传输文件可以使用串口的xmodem/ymodem/zmodem协议, 使用简单, 但是速度慢; 
				网络通过tftp,nfs协议;
				使用USB.
				
BootLoader的结构和启动过程
		嵌入式系统通常分为四个层次:
			(1) 引导加载程序, 包括固化在固件(firmware)中的boot代码(可选)和BootLoader两大部分
				大多数嵌入式系统没有固件, BootLoader是上电后执行的第一个程序.
				x86结构的系统先运BIOS的固件, 然后才运行硬件第一个分区的BootLoader.
			(2) linux内核
				特定于嵌入式板子的定制内核以及内核的启动参数, 内核的启动参数可以是默认的, 也可以是由BootLoader传递过来的.
			(3) 文件系统
				包括根文件系统和建立在Flash内存设备上的文件系统, 里面包含了LInux系统能够运行所必须的应用程序, 库等.
			(4) 用户应用程序
				特定于用户的应用程序, 它们也存储在文件系统中. 有时还会在应用程序和内核层之间可能还会包含一个嵌入式图形用户界面.
				
				Boot parameters分区中存放一些可设置的参数, 比如IP地址, 串口波特率, 要传递给内核的命令行参数等. 
				正常的启动过程中, BootLoader首先运行起来, 然后它将内核复制到内存中(有些内核可以在固态存储器中直接运行), 并且在内存某个固定的地址设置好要传递给内核的参数, 最后运行内核. 内核启动以后, 它会挂载mount根文件系统root filesystem, 启动文件系统中的应用程序.

	BootLoader两个阶段:
		启动过程可以分为single stage单阶段, multi-stage多阶段两种.
		通常多阶段的BootLoader能提供更复杂的功能, 以及更好的可移植性. 从固态存储设备上启动的BootLoader大多数都是两个阶段的启动过程:
			(1) 第一阶段: 使用汇编来实现, 它完成一些依赖于CPU体系结构的初始化, 并调用第二阶段的代码;
				BootLoader第一阶段的功能:
					▶硬件设备初始化;
						关闭watchdog, 关中断, 设置好CPU的速度和时钟频率, RAM初始化等.(但这些并不是必需的, S3C2440开发板使用的u-boot将CPU的速度和时钟频率的设置放在了第二阶段)
					▶为加载BootLoader的第二阶段代码准备RAM空间;
					▶复制BootLoader第二阶段代码到RAM空间中;
						这点也不是必需的, 对于Nor Flash等存储设备, 完全可以在上面直接执行代码, 只不多相比在RAM中执行效率大为降低.
					▶设置好堆栈;
					▶跳转到第二阶段的C入口点;
					
			(2) 第二阶段: 通常使用C语言来实现, 这样可以实现更复杂的功能, 而且代码会有更好的可读性和可移植性.
				BootLoader第二阶段的功能
					▶初始化本阶段用使用到的硬件设备;
					▶监测系统内存映射;
						所谓监测内存映射, 就是确定板上使用了多少内存, 它们的地址空间是什么, 根据板子的情况直接设置.
					▶将内存映射和根文件系统映像从Flash上读到RAM空间中;
						这点不是必需的, 这取决于什么类型的根文件系统, 已经内核访问它的方法.
						Flash上的内存映像可能是经过压缩的, 在读到RAM以后, 还需要进行解压, 当然对于有自解压功能的内核, 不需要BootLoader来解压.
					▶为内核设置启动参数;
					▶调用内核;
						将内核存放到合适的位置后, 直接跳到它的入口点即可调用内核. 调用内核之前, 必须要满足以下条件:
							① CPU寄存器的设置:
								R0 = 0;
								R1 = 机器类型ID;
									对于ARM结构的CPU, 其机器类型的ID可以参见linux/arch/arm/tools/mach-types.
								R2 = 启动参数标记列表在ARM中的起始基地址.
							② CPU的工作模式:
								必须禁止中断(IRQs, FIQs);
								CPU必须为SVC模式.
							③ Cache和MMU的设置:
								MMU必须关闭;
								指令Cache可以打开也可以关闭;
								数据Cache必须关闭;
						如果使用C语言, 可以像下列示例一样调用内核:
							void (*theKernel) (int zero, int arch, u32 params_addr) = (void (*) (int, int, u32))KERNEL_RAM_BASE;
							...
							theKernel (0, ARCH_NUMBER, (u32)kernel_params_start;
							
			为了开发方便, 至少要初始化一个串口以便程序员和BootLoader进行交互.
			
		
			
	
